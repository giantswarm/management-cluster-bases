# EKS Deployment with `helm-controller`

> **Note**
>
> Until [the changes proposed as part of the app platform migration](https://github.com/giantswarm/giantswarm/blob/f15f532b39310b8e6cc06a192605d507a672eeee/content/docs/dev-and-releng/chart-operator-to-helm-controller-migration/_index.md)
> are complete it is not currently possible to undertake deployments utilising
> the platform components to deliver workloads to EKS clusters anticipated to
> be entirely under the control of the customer.
>
> This is the result of a long overdue revamp of the platform, coupled with the
> necessity to impose as small a footprint as possible on customer managed
> clusters where that footprint may interfere with existing customer workloads.
>
> Whilst this is less than ideal, the immediate mitigation is to use
> `helm-controller`, part of the `fluxcd` stack to deploy to EKS clusters for
> the purposes of validating apps

In order to support deployments to EKS clusters as an interim step, these
examples demonstrate the use of `HelmRelease` CRs as an alternative method to
using our own `App` CRs.

If you wish to jump direct to the examples of how to achieve deployments to a
remote cluster, please see

- [`helmrelease`](./helmrelease/)

> **Note**
>
> Removed from this sample set was an additional kustomize deploy example.
>
> That particular example had very few differences from the `mapi/out-of-band`
> examples given in the gitops-template.
>
> For a more consise rundown, please see the [documentation](https://github.com/giantswarm/gitops-template/blob/main/docs/repo_structure.md#mapi-and-out-of-band)
> and [equivalent example](https://github.com/giantswarm/gitops-template/blob/main/management-clusters/MC_NAME/organizations/ORG_NAME/workload-clusters/WC_NAME_OUT_OF_BAND_NO_FLUX_APP-direct.yaml)
> in the [`gitops-template`](https://github.com/giantswarm/gitops-template/tree/main) repository.

## What is a `HelmRelease`

If you're new to the concept of `HelmRelease` CRs, you may be wondering what the
difference is and how they work in relation to our own `App` CR.

Overall the similarities between these two types outweigh the differences with
the key difference being how values are defined for the types.

Inside `App` CRs, we have the concept of `userConfig` and `extraConfig` with
`userConfig` having priority 100 and `extraConfig` accepting priorities at
different levels allowing you to define the order in which values are merged
together to present an app or collection of apps to the target deployment. This
allows for some flexibility with ordering as resources may be ready at different
times

`HelmRelease` CRs do not allow the same priority definition but instead
take their priority from the position in the list of `ValuesFrom` with elements
lower in the list naturally overriding those higher. These values are laid as
a base in the order given, and then any values provided in `spec.values` are
overlaid on top.

Both types allow for merging values from both `ConfigMap` and `Secret` thus for
the HelmRelease example of:

```yaml
spec:
  values:
    replicaCount: 2
  valuesFrom:
    - kind: ConfigMap
      name: prod-env-values
      valuesKey: values-prod.yaml
    - kind: Secret
      name: prod-tls-values
      valuesKey: crt
      targetPath: tls.crt
      optional: true
```

We would see the values in the ConfigMap laid down first, then the secret
overlaid on top of these, then finally the `replicaCount` would overlay this.

To equate the same behaviour inside `App` CR the ConfigMap would be an
`extraConfig` of priority `98`, the secret `99` and finally the `userConfig.configMap`
and `userConfig.secret` values would be layered in.

### Catalog secrets

One thing to be noted with the `HelmRelease` process that differs from the app
platform is the treatment of `catalog` secrets and configmaps.

Under the app platform, there may be values coming from the catalog that apply
as a base layer upon which everything else is merged (e.g. catalog has 
priority 0)

This capability is lost with `HelmRelease` objects and these must contain all
configuration options as `values` and `valuesFrom` references as part of the 
spec.

### Deployment

When deploying `App` CRs, you have the option of specifying `inCluster` true to
deploy to the management cluster, or `false` along with a related `kubeconfig`
to deploy to a remote cluster. Within our app-platform, the kubeconfig is
injected for you as long as the app is annotated correctly with the cluster
name.

HelmReleases work in an identical fashion in this regard although they do not
have the luxury of having the kubeconfig injected, and instead this **must**
be specified manually as part of the deployment for the chart to be deployed
to the correct remote cluster.

Unlike `App` CRs a key inside the secret may also be specified. This is
important when using the `kubeconfig` generated by crossplane but less important
when using a normal GS `kubeconfig` or one generated via CAPI.

**Note** At the time of writing, we do not have visibility over whether CAPI
generated kubeconfig secrets will be available for customer managed EKS clusters.

```yaml
spec:
  kubeConfig:
    secretRef:
      name: sample-customer-kubeconfig-cluster-auth
      key: kubeconfig
```

### Errors

When a chart fails to deploy, the App platform tries to gather reasons why and
populate this back to the App CR status.

Whilst `HelmRelease` tries to achieve the same, there are reports that the errors
from this process are less verbose than those generated from the App Platform.

This is a limitation of the tooling and not one we have immediate control over.

Please take this into consideration when working with `HelmRelease` CRs.
